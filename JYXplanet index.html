<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JYX Planet - 永恒记忆星系</title>
    <!-- 引入 Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入 MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <!-- 引入 Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, collection, onSnapshot, addDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'jyx-planet';

        window.db = db;
        window.auth = auth;
        window.appId = appId;

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                window.currentUser = user;
                try {
                    await user.getIdToken(true);
                    window.loadMemories();
                } catch(e) { console.error("Token刷新失败", e); }
            } else {
                try {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) { console.error("认证失败:", error); }
            }
        });
    </script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'PingFang SC', sans-serif; color: white; }
        #container { width: 100vw; height: 100vh; cursor: crosshair; }
        #input-video { display: none; }
        
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 10;
        }
        
        .status-badge {
            background: rgba(255, 50, 50, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            border: 1px solid rgba(255, 50, 50, 0.4);
            display: inline-block;
            margin-bottom: 10px;
            backdrop-filter: blur(10px);
            font-size: 13px;
        }

        #control-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 20;
            pointer-events: auto;
        }

        .glass-box {
            background: rgba(15, 5, 5, 0.85);
            border: 1px solid rgba(255, 50, 50, 0.3);
            padding: 15px;
            border-radius: 12px;
            width: 260px;
            backdrop-filter: blur(15px);
        }

        .box-label { font-size: 11px; color: #ff4d4d; margin-bottom: 8px; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }

        textarea {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: white;
            padding: 8px;
            font-size: 12px;
            resize: none;
            height: 60px;
            margin-bottom: 8px;
            outline: none;
        }

        .action-btn {
            width: 100%;
            background: rgba(255, 50, 50, 0.2);
            border: 1px solid #ff4d4d;
            color: #ff4d4d;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: 0.3s;
        }
        .action-btn:hover { background: rgba(255, 50, 50, 0.4); }

        #photo-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 25px;
            border-radius: 20px;
            border: 1px solid #00d2ff;
            display: none;
            text-align: center;
            width: 380px;
            z-index: 100;
        }

        #memory-image-container {
            width: 100%;
            height: 220px;
            margin: 15px 0;
            background: #111;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #333;
        }

        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #ff4d4d;
        }
    </style>
</head>
<body>

<div id="loader">
    <div style="margin-bottom: 20px;">正在连接 JYX 红色主星...</div>
    <div style="font-size: 10px; opacity: 0.6;">手势感应系统加载中...</div>
</div>

<div id="ui-overlay">
    <div class="status-badge">
        主星状态: <span id="sync-status" style="color:#ff4d4d">稳定</span>
    </div><br>
    <div class="status-badge" style="font-size: 11px; opacity: 0.8; border-color: #00d2ff; color: #00d2ff;">
        记忆统计: <span id="memory-count">0</span> 处地表异能
    </div>
</div>

<div id="control-panel">
    <div class="glass-box" id="edit-box" style="display:none;">
        <div class="box-label">记忆修正协议</div>
        <textarea id="manual-input"></textarea>
        <button class="action-btn" onclick="saveCorrection()">更新至云端</button>
    </div>

    <div class="glass-box">
        <div class="box-label">记忆刻录</div>
        <label for="file-input" style="display:block; padding:10px; border:1px dashed #ff4d4d; color:#ff4d4d; text-align:center; font-size:11px; cursor:pointer;">
            点击上传影像
        </label>
        <input id="file-input" type="file" accept="image/*" style="display:none" onchange="handleFile(event)" />
        
        <div id="injection-preview" style="display:none; margin-top:10px;">
            <img id="preview-thumb" style="width:100%; border-radius:4px; margin-bottom:8px; border: 1px solid #00d2ff;">
            <textarea id="injection-text" placeholder="描述这段记忆..."></textarea>
            <button class="action-btn" id="sync-btn" onclick="uploadMemory()" style="border-color: #00d2ff; color: #00d2ff; background: rgba(0, 210, 255, 0.1);">刻录至地表</button>
        </div>
    </div>
</div>

<div id="photo-overlay">
    <div id="memory-image-container"><img id="memory-image" style="max-width: 100%; max-height: 100%;"></div>
    <div id="ai-memory-text" style="font-size: 14px; margin-bottom: 20px; color: #00d2ff;">读取中...</div>
    <button onclick="closePhoto()" style="background:#ff4d4d; color:black; border:none; padding:8px 25px; border-radius:20px; cursor:pointer; font-weight:bold;">返回星系</button>
</div>

<video id="input-video" playsinline></video>
<div id="container"></div>

<script type="module">
    import { collection, onSnapshot, addDoc, updateDoc, doc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    let MEMORY_DATA = [];
    let currentSelectedId = null;
    let pendingImage = null; // 存储压缩后的 Base64
    let unsubscribe = null;

    // --- 图片压缩工具函数 ---
    async function compressImage(base64Str, maxWidth = 800, quality = 0.7) {
        return new Promise((resolve) => {
            const img = new Image();
            img.src = base64Str;
            img.onload = () => {
                const canvas = document.createElement('canvas');
                let width = img.width;
                let height = img.height;

                if (width > maxWidth) {
                    height = (maxWidth / width) * height;
                    width = maxWidth;
                }

                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                // 转换为 JPEG 以通过 quality 参数有效压缩体积
                resolve(canvas.toDataURL('image/jpeg', quality));
            };
        });
    }

    // --- 数据持久化 ---
    window.loadMemories = function() {
        if (!window.currentUser || !window.db) return;
        if (unsubscribe) unsubscribe();

        const memoriesCol = collection(window.db, 'artifacts', window.appId, 'users', window.currentUser.uid, 'memories');
        
        unsubscribe = onSnapshot(memoriesCol, (snapshot) => {
            MEMORY_DATA = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
            document.getElementById('memory-count').innerText = MEMORY_DATA.length;
            window.updateThreePoints();
            document.getElementById('loader').style.display = 'none';
            document.getElementById('sync-status').innerText = "实时同步中";
        }, (err) => {
            console.error("Firestore 同步异常:", err);
            setTimeout(() => window.loadMemories(), 5000);
        });
    };

    window.handleFile = function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = async (ev) => {
            // 预先显示原图预览
            document.getElementById('preview-thumb').src = ev.target.result;
            document.getElementById('injection-preview').style.display = 'block';
            
            // 异步进行压缩，并将结果存入 pendingImage
            pendingImage = await compressImage(ev.target.result);
            console.log("图片已重采样压缩以适配云端存储限制");
        };
        reader.readAsDataURL(file);
    };

    window.uploadMemory = async function() {
        if (!pendingImage || !window.currentUser) return;
        const btn = document.getElementById('sync-btn');
        btn.disabled = true; btn.innerText = "刻录中...";
        try {
            const col = collection(window.db, 'artifacts', window.appId, 'users', window.currentUser.uid, 'memories');
            await addDoc(col, {
                url: pendingImage,
                text: document.getElementById('injection-text').value || "一段尘封的记忆",
                time: Date.now()
            });
            document.getElementById('injection-preview').style.display = 'none';
            pendingImage = null;
        } catch (e) { 
            console.error("上传错误:", e);
            // 这里不使用 alert，在按钮上提示
            btn.innerText = "存储溢出或失败";
            setTimeout(() => { btn.disabled = false; btn.innerText = "重试刻录"; }, 2000);
        } finally {
            if (pendingImage === null) {
                btn.disabled = false; btn.innerText = "刻录至地表";
            }
        }
    };

    window.saveCorrection = async function() {
        if (!currentSelectedId || !window.currentUser) return;
        const dRef = doc(window.db, 'artifacts', window.appId, 'users', window.currentUser.uid, 'memories', currentSelectedId);
        await updateDoc(dRef, { text: document.getElementById('manual-input').value });
    };

    // --- 三维系统 ---
    let scene, camera, renderer, globe, nebula, memoryGroup;
    let targetDist = 350, currentDist = 350;
    let manualRotationY = 0; 
    let raycaster = new THREE.Raycaster();
    raycaster.params.Points.threshold = 8;
    let mouse = new THREE.Vector2();

    function initThree() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 3000);
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('container').appendChild(renderer.domElement);

        const geo = new THREE.BufferGeometry();
        const particleCount = 18000;
        const pos = new Float32Array(particleCount * 3);
        for(let i=0; i < particleCount; i++) {
            const r = 90; 
            const p = Math.acos(-1 + (2*i)/particleCount);
            const t = Math.sqrt(particleCount * Math.PI) * p;
            pos[i*3] = r * Math.cos(t) * Math.sin(p);
            pos[i*3+1] = r * Math.sin(t) * Math.sin(p);
            pos[i*3+2] = r * Math.cos(p);
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        globe = new THREE.Points(geo, new THREE.PointsMaterial({ 
            size: 2.5, 
            color: 0xff1a1a, 
            transparent: true, 
            opacity: 0.7,
            blending: THREE.AdditiveBlending 
        }));
        scene.add(globe);

        const nebulaGeo = new THREE.BufferGeometry();
        const nebulaCount = 6000;
        const nebulaPos = new Float32Array(nebulaCount * 3);
        for(let i=0; i < nebulaCount; i++) {
            const r = 100 + Math.random() * 120; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            nebulaPos[i*3] = r * Math.sin(phi) * Math.cos(theta);
            nebulaPos[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            nebulaPos[i*3+2] = r * Math.cos(phi);
        }
        nebulaGeo.setAttribute('position', new THREE.BufferAttribute(nebulaPos, 3));
        nebula = new THREE.Points(nebulaGeo, new THREE.PointsMaterial({
            size: 1.5,
            color: 0xffffff,
            transparent: true,
            opacity: 0.2,
            blending: THREE.AdditiveBlending
        }));
        scene.add(nebula);

        memoryGroup = new THREE.Group();
        scene.add(memoryGroup);

        window.addEventListener('click', onClick);
        animate();
    }

    window.updateThreePoints = function() {
        while(memoryGroup.children.length > 0) memoryGroup.remove(memoryGroup.children[0]);
        if (MEMORY_DATA.length === 0) return;

        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(MEMORY_DATA.length * 3);
        const ids = [];
        
        MEMORY_DATA.forEach((m, i) => {
            const r = 90.5; 
            const p = Math.acos(-1 + (2*i)/MEMORY_DATA.length);
            const t = Math.sqrt(MEMORY_DATA.length * Math.PI) * p;
            pos[i*3] = r * Math.cos(t) * Math.sin(p);
            pos[i*3+1] = r * Math.sin(t) * Math.sin(p);
            pos[i*3+2] = r * Math.cos(p);
            ids.push(m.id);
        });
        
        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        const mat = new THREE.PointsMaterial({ 
            size: 2.5, 
            color: 0x00d2ff, 
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 1.0 
        });
        const pts = new THREE.Points(geo, mat);
        pts.userData.ids = ids;
        memoryGroup.add(pts);
    };

    function onClick(e) {
        if (e.target.tagName !== 'CANVAS') return;
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        
        const intersects = raycaster.intersectObjects(memoryGroup.children);
        if (intersects.length > 0) {
            const intersection = intersects[0];
            const id = intersection.object.userData.ids[intersection.index];
            const data = MEMORY_DATA.find(d => d.id === id);
            currentSelectedId = id;
            document.getElementById('memory-image').src = data.url;
            document.getElementById('ai-memory-text').innerText = data.text;
            document.getElementById('manual-input').value = data.text;
            document.getElementById('edit-box').style.display = 'block';
            document.getElementById('photo-overlay').style.display = 'block';
        }
    }

    window.closePhoto = () => {
        document.getElementById('photo-overlay').style.display = 'none';
        document.getElementById('edit-box').style.display = 'none';
    };

    function animate() {
        requestAnimationFrame(animate);
        currentDist += (targetDist - currentDist) * 0.1;
        camera.position.z = currentDist;
        camera.lookAt(0,0,0);
        
        const baseSpeed = 0.0012;
        const currentRotationSpeed = baseSpeed + manualRotationY;
        
        globe.rotation.y += currentRotationSpeed;
        memoryGroup.rotation.y += currentRotationSpeed; 
        
        nebula.rotation.y -= (baseSpeed * 0.3); 
        nebula.rotation.x += 0.0001;
        
        manualRotationY *= 0.92;
        renderer.render(scene, camera);
    }

    initThree();

    // 手势识别
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ 
        maxNumHands: 1, 
        modelComplexity: 1, 
        minDetectionConfidence: 0.6, 
        minTrackingConfidence: 0.6 
    });

    hands.onResults(results => {
        if (results.multiHandLandmarks?.[0]) {
            const lm = results.multiHandLandmarks[0];
            const isOpen = lm[8].y < lm[5].y; 
            if (isOpen) targetDist = Math.max(150, targetDist - 12);
            else targetDist = Math.min(800, targetDist + 12);

            const dx = lm[17].x - lm[5].x;
            const dy = lm[17].y - lm[5].y;
            const tilt = dy / (Math.abs(dx) + 0.0001); 

            if (Math.abs(tilt) > 0.1) {
                manualRotationY = Math.max(-0.05, Math.min(0.05, -tilt * 0.08));
            }
        }
    });

    const video = document.getElementById('input-video');
    const cameraHelper = new Camera(video, {
        onFrame: async () => { if (video.readyState >= 2) await hands.send({image: video}); },
        width: 640, height: 480
    });
    cameraHelper.start().catch(e => {
        console.error("相机启动失败:", e);
        document.getElementById('loader').innerText = "请授予相机权限以体验手势控制";
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
